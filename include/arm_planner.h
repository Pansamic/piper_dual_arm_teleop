/**
 * @file arm_planner.h
 * @author pansamic (pansamic@foxmail.com)
 * @brief AgileX Piper robotic arm trajectory planner.
 * @version 0.1
 * @date 2025-06-12
 * 
 * @copyright Copyright (c) 2025
 * 
 */
#ifndef __ARM_PLANNER_H__
#define __ARM_PLANNER_H__

#include <trajectory_buffer.hpp>
#include <arm_model.h>

class ArmPlanner
{
public:
    /* waypoints to avoid obstacles, 
     * generated by obstacle avoidance algorithms like CHOMP. */
    static const size_t num_plan_waypoint_ = 10;

    /**
     * @brief Construct a new Arm Planner object
     * 
     * @param left_arm_trajectory_buffer reference of left arm trajectory buffer.
     * @param right_arm_trajectory_buffer reference of right arm trajectory buffer.
     * @param freq_plan plan thread loop frequency, unit: Hz.
     * @param freq_ctrl control thread loop frequency, unit: Hz.
     */
    ArmPlanner(
        TrajectoryBuffer<num_plan_waypoint_>& left_arm_trajectory_buffer,
        TrajectoryBuffer<num_plan_waypoint_>& right_arm_trajectory_buffer,
        size_t freq_plan);
    ~ArmPlanner() = default;
    void start();
    void stop();
    void setLeftArmTargetJointPosition(const Eigen::Vector<double,ArmModel::num_dof_>& joint_pos);
    void setRightArmTargetJointPosition(const Eigen::Vector<double,ArmModel::num_dof_>& joint_pos);
private:
    bool running_;
    /* planner loop interval, unit: second */
    double dt_plan_;

    /* This buffer is used to store */
    std::mutex left_arm_target_joint_pos_mtx_;
    Eigen::Vector<double,ArmModel::num_dof_> left_arm_target_joint_pos_;
    std::mutex right_arm_target_joint_pos_mtx_;
    Eigen::Vector<double,ArmModel::num_dof_> right_arm_target_joint_pos_;

    TrajectoryBuffer<num_plan_waypoint_>& left_arm_trajectory_buffer_;
    TrajectoryBuffer<num_plan_waypoint_>& right_arm_trajectory_buffer_;

    std::thread plan_thread_;
    /**
     * @brief Linear waypoints generation without obstacle avoidance and self collision.
     * 
     * @param begin beginning configuration of robotic arm.
     * @param end end configuration of robotic arm.
     */
    void planDualArmLinear(
        const std::chrono::steady_clock::time_point& start_timepoint,
        const Eigen::Vector<double,ArmModel::num_dof_>& left_arm_begin,
        const Eigen::Vector<double,ArmModel::num_dof_>& left_arm_end,
        const Eigen::Vector<double,ArmModel::num_dof_>& right_arm_begin,
        const Eigen::Vector<double,ArmModel::num_dof_>& right_arm_end);

    /**
     * @brief Covariant Hamilton Optimization Motion Planning.
     * 
     * @param begin beginning configuration of robotic arm.
     * @param end end configuration of robotic arm.
     * @todo Add obstacle expression and finish CHOMP algorithm.
     */
    void planDualArmCHOMP(
        const Eigen::Vector<double,ArmModel::num_dof_>& begin,
        const Eigen::Vector<double,ArmModel::num_dof_>& end);

    void threadPlan(void);
};

#endif // __ARM_PLANNER_H__