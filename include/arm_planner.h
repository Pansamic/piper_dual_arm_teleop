/**
 * @file arm_planner.h
 * @author pansamic (pansamic@foxmail.com)
 * @brief AgileX Piper robotic arm trajectory planner.
 * @version 0.1
 * @date 2025-06-12
 * 
 * @copyright Copyright (c) 2025
 * 
 */
#ifndef __ARM_PLANNER_H__
#define __ARM_PLANNER_H__

#include <condition_variable>
#include <arm_model.h>

struct WayPoint
{
    Eigen::Vector<double,ArmModel::num_dof_> joint_pos;
    Eigen::Vector<double,ArmModel::num_dof_> joint_vel;
    /* joint acceleration is not necessary because joint level control
     * is MIT mode (position and velocity control) */
    // Eigen::Vector<double,ArmModel::num_dof_> joint_acc;
};

template<typename T>
class RingBuffer
{
public:
    explicit RingBuffer(size_t capacity):
        head_(0), tail_(0), capacity_(capacity), size_(0), empty_(true), full_(false)
    {
        this->buffer_.resize(capacity);
    }
    ~RingBuffer() = default;
    void push(const T& value)
    {
        std::lock_guard<std::mutex> lock(this->mtx_);

        if ( this->full_ )
        {
            throw std::overflow_error("ring buffer overflow");
        }

        buffer_[tail_] = value;
        tail_ = (tail_ + 1) % capacity_;
        ++size_;

        if (size_ == capacity_)
        {
            full_ = true;
        }
        empty_ = false;
    }
    void pop(T& value)
    {
        std::lock_guard<std::mutex> lock(mtx_);

        if ( this->empty_ )
        {
            throw std::underflow_error("ring buffer underflow");
        }

        value = buffer_[head_];
        head_ = (head_ + 1) % capacity_;
        --size_;

        if (size_ == 0)
        {
            empty_ = true;
        }

        full_ = false;
    }

    bool empty() const
    {
        std::lock_guard<std::mutex> lock(mtx_);
        return empty_;
    }

    bool full() const
    {
        std::lock_guard<std::mutex> lock(mtx_);
        return full_;
    }

    size_t size() const
    {
        std::lock_guard<std::mutex> lock(mtx_);
        return size_;
    }
private:
    int head_;
    int tail_;
    size_t capacity_;
    size_t size_;
    std::mutex mtx_;
    bool empty_;
    bool full_;
    std::vector<T> buffer_;
};

class ArmPlanner
{
public:
    /**
     * @brief Construct a new Arm Planner object
     * 
     * @param freq_plan plan thread loop frequency, unit: Hz.
     * @param freq_ctrl control thread loop frequency, unit: Hz.
     */
    ArmPlanner(size_t freq_plan, size_t freq_ctrl);
    ~ArmPlanner() = default;
    void setLeftArmTargetWayPoint(const WayPoint& waypoint);
    void setRightArmTargetWayPoint(const WayPoint& waypoint);
    void getLeftArmWayPoint(WayPoint& waypoint);
    void getRightArmWayPoint(WayPoint& waypoint);
private:
    std::atomic<bool> running_ = false;
    /* planner loop interval, unit: second */
    double dt_plan_;
    /* controller loop interval, unit: second */
    double dt_ctrl_;
    /* amount of waypoints in a trajectory */
    size_t traj_len_;
    /* trajectory amount in buffer, indicates how many continuous
     * trajectories are stored in buffer. */
    static const size_t traj_buf_len_ = 3;
    /* used to mark the end waypoint of last trajectory slice
     * for continuous planning */
    WayPoint left_arm_last_end_waypoint_;
    WayPoint right_arm_last_end_waypoint_;
    WayPoint left_arm_target_waypoint_;
    WayPoint right_arm_target_waypoint_;

    RingBuffer<WayPoint> left_arm_trajectory_buffer_;
    RingBuffer<WayPoint> right_arm_trajectory_buffer_;

    /* waypoints to avoid obstacles, 
     * generated by obstacle avoidance algorithms like CHOMP. */
    static const size_t plan_waypoint_amount_ = 10;

    std::thread plan_thread_;

    /**
     * @brief Perform linear interpolation on the trajectory waypoints.
     * 
     * @param waypoints waypoint array, usually from planner function.
     * 
     * @note Write interpolated trajectory to `this->left_arm_trajectory_buffer_` or
     * `this->right_arm_trajectory_buffer_`
     */
    void interpolateLinear(
        RingBuffer<WayPoint>& traj_buf,
        const std::array<WayPoint, plan_waypoint_amount_>& waypoints);
    /**
     * @brief Perform B-spline interpolation on the trajectory waypoints.
     * 
     * @param waypoints waypoint array, usually from planner function.
     * 
     * @note Write interpolated trajectory to `this->left_arm_trajectory_buffer_` or
     * `this->right_arm_trajectory_buffer_`
     */
    void interpolateBSpline(
        RingBuffer<WayPoint>& traj_buf,
        const std::array<WayPoint, plan_waypoint_amount_>& waypoints);
    /**
     * @brief Perform quintic polynomial interpolation on the trajectory waypoints.
     * 
     * @param waypoints waypoint array, usually from planner function.
     * 
     * @note Write interpolated trajectory to `this->left_arm_trajectory_buffer_` or
     * `this->right_arm_trajectory_buffer_`
     */
    void interpolateQuinticPolynomial(
        RingBuffer<WayPoint>& traj_buf,
        const std::array<WayPoint, plan_waypoint_amount_>& waypoints);

    /**
     * @brief Linear waypoints generation without obstacle avoidance and self collision.
     * 
     * @param begin beginning configuration of robotic arm.
     * @param end end configuration of robotic arm.
     */
    void planDualArmLinear(
        std::array<WayPoint, plan_waypoint_amount_>& left_arm_plan_waypoints,
        std::array<WayPoint, plan_waypoint_amount_>& right_arm_plan_waypoints,
        const WayPoint& left_arm_begin,
        const WayPoint& left_arm_end,
        const WayPoint& right_arm_begin,
        const WayPoint& right_arm_end);

    /**
     * @brief Covariant Hamilton Optimization Motion Planning.
     * 
     * @param begin beginning configuration of robotic arm.
     * @param end end configuration of robotic arm.
     * @todo Add obstacle expression and finish CHOMP algorithm.
     */
    void planDualArmCHOMP(
        std::array<WayPoint, plan_waypoint_amount_>& plan_waypoints,
        const WayPoint& begin,
        const WayPoint& end);

    void threadPlan(void);
};

#endif // __ARM_PLANNER_H__