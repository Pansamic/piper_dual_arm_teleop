/**
 * @file arm_planner.h
 * @author pansamic (pansamic@foxmail.com)
 * @brief AgileX Piper robotic arm trajectory planner.
 * @version 0.1
 * @date 2025-06-12
 * 
 * @copyright Copyright (c) 2025
 * 
 */
#ifndef __ARM_PLANNER_H__
#define __ARM_PLANNER_H__

#include <condition_variable>
#include <joint_state.h>
#include <trajectory_buffer.h>
// #include <itc/backend/RingBuf.hpp>
#include <arm_model.h>

class ArmPlanner
{
public:
    /* waypoints to avoid obstacles, 
     * generated by obstacle avoidance algorithms like CHOMP. */
    static const size_t num_plan_waypoint_ = 10;

    /**
     * @brief Construct a new Arm Planner object
     * 
     * @param left_arm_trajectory_buffer reference of left arm trajectory buffer.
     * @param right_arm_trajectory_buffer reference of right arm trajectory buffer.
     * @param freq_plan plan thread loop frequency, unit: Hz.
     * @param freq_ctrl control thread loop frequency, unit: Hz.
     */
    ArmPlanner(
        TrajectoryBuffer<num_plan_waypoint_>& left_arm_trajectory_buffer,
        TrajectoryBuffer<num_plan_waypoint_>& right_arm_trajectory_buffer,
        size_t freq_plan);
    ~ArmPlanner();
    void setLeftArmTargetJointState(const JointState& joint_state);
    void setRightArmTargetJointState(const JointState& joint_state);
private:
    std::atomic<bool> running_;
    /* planner loop interval, unit: second */
    double dt_plan_;
    /* controller loop interval, unit: second */
    // double dt_ctrl_;
    /* amount of waypoints in a trajectory */
    // size_t traj_len_;

    /* used to mark the end waypoint of last trajectory slice
     * for continuous planning */
    JointState left_arm_last_target_joint_state_;
    JointState right_arm_last_target_joint_state_;

    /* This buffer is used to store */
    std::mutex left_arm_target_joint_state_mtx_;
    JointState left_arm_target_joint_state_;
    std::mutex right_arm_target_joint_state_mtx_;
    JointState right_arm_target_joint_state_;

    TrajectoryBuffer<num_plan_waypoint_>& left_arm_trajectory_buffer_;
    TrajectoryBuffer<num_plan_waypoint_>& right_arm_trajectory_buffer_;

    std::thread plan_thread_;

    /**
     * @brief Perform linear interpolation on the trajectory waypoints.
     * 
     * @param waypoints waypoint array, usually from planner function.
     * 
     * @note Write interpolated trajectory to `this->left_arm_trajectory_buffer_` or
     * `this->right_arm_trajectory_buffer_`
     */
    // void interpolateLinear(
    //     RingBuffer<JointState>& traj_buf,
    //     const std::array<JointState, num_plan_waypoint_>& waypoints);
    /**
     * @brief Perform B-spline interpolation on the trajectory waypoints.
     * 
     * @param waypoints waypoint array, usually from planner function.
     * 
     * @note Write interpolated trajectory to `this->left_arm_trajectory_buffer_` or
     * `this->right_arm_trajectory_buffer_`
     */
    // void interpolateBSpline(
    //     RingBuffer<JointState>& traj_buf,
    //     const std::array<JointState, num_plan_waypoint_>& waypoints);
    /**
     * @brief Perform quintic polynomial interpolation on the trajectory waypoints.
     * 
     * @param waypoints waypoint array, usually from planner function.
     * 
     * @note Write interpolated trajectory to `this->left_arm_trajectory_buffer_` or
     * `this->right_arm_trajectory_buffer_`
     */
    // void interpolateQuinticPolynomial(
    //     RingBuffer<JointState>& traj_buf,
    //     const std::array<JointState, num_plan_waypoint_>& waypoints);

    /**
     * @brief Linear waypoints generation without obstacle avoidance and self collision.
     * 
     * @param begin beginning configuration of robotic arm.
     * @param end end configuration of robotic arm.
     */
    void planDualArmLinear(
        const JointState& left_arm_begin,
        const JointState& left_arm_end,
        const JointState& right_arm_begin,
        const JointState& right_arm_end);

    /**
     * @brief Covariant Hamilton Optimization Motion Planning.
     * 
     * @param begin beginning configuration of robotic arm.
     * @param end end configuration of robotic arm.
     * @todo Add obstacle expression and finish CHOMP algorithm.
     */
    void planDualArmCHOMP(
        const JointState& begin,
        const JointState& end);

    void threadPlan(void);
};

#endif // __ARM_PLANNER_H__